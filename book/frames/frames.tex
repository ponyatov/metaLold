\secrel{Концепция фреймов Марвина Мински}\label{frame}\secdown


\cite{minsky} Марвин Минский \textbf{Фреймы для представления знаний}
\bigskip

\begin{itemize}
%   \item 
% \url{https://royallib.com/read/minskiy_marvin/freymi_dlya_predstavleniya_znaniy.html#0}
  \item 
\url{https://ponyatov.quora.com/Minsky-Frames-Database-metaL}\\(см. видео в
начале)
\end{itemize}

В качестве модели представления (мета)программ было выбрано расширенное
представление фреймов Мински (как базовый класс). Оригинальные фреймы не имели
очень важного для метапрограммирования функционала: способности хранить
упорядоченные объекты. Эта фича необходима для представления любых
программ\note{последовательного набора инструкций, или рекурсивных структур}, в
качестве примера см. деревья разбора/AST и реализацию атрибутных грамматик
\cite{dragon2}.

% С другой стороны, фреймы имеют практически полное соответстивие объектной
% парадигме, в т.ч. объектам Python. И если мы попытаемся описать дерево программы
% через граф питоновских объектов, мы сталкиваемся с необходимостью вводить
% упорядоченные контейнеры, например для хранения операндов в выражении деления.
% 
% Для некоторой универсализации, 
% * отделения логики фреймов от логики работы объектной системы в Python,
% * возможности реализации на низкоуровневых языках с жесткой типизацией,
%   AOT-компиляцией и соответственно невозможностью произвольно менять структуру
%   класса или единичного объекта в рантайме (C++, Java)
% * добавления некоторых фич характерных для функциональных и логических языков 
%   программирования (унификация/backtracking и структурный pattern matching),
% 
% было выбрано расширение концепта фрейма, предложенного Марвином Мински,
% добавлением функционала упорядоченного контейнера `nest[]`, позволяющего
% не только хранить `attr{}`ибуты (слоты),
% но и любые элементы данных в явно заданном порядке.
% 
% 	class Frame:
%     	def __init__(self,V):
%         	self.type  = self.__class__.__name__.lower()
%         	self.value = V
%         	self.attr  = {}
%         	self.nest  = []
% 
% 	print Frame('hello')
% 
% 	<frame:hello>
% 
% 
% Также в большинстве случаев у нас есть необходимость хранить для любого
% элемента данных два поля:
% * `type` <br>
% явно указывающий на тип фрейма. Мы принципиально не можем оперировать
% двумя фреймами в выражении типа `<string:> + <number:>` без их приведения к
% одному типу, причем это приведение часто зависит от контекста, в каком именно
% смысле мы это выражение используем (привет долбанутый JavaScript)
% * `value` <br>
% атомарное значение, хранимое в типе языка реализации (Python): нам нужно
% именовать объекты, хранить значение строк и числовых данных, поэтому также
% необходимо подкласс фреймов для представления таких значений-примитивов.
%   
% (*) имена type/value фиксированы требованиями библиотеки PLY, если вы захотите
% использовать ее для создания собтвенного языка метапрограммирования или CLI
% вместо Python

\secup
